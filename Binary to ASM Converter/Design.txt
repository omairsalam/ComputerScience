Omair Alam oa6ci:
Design Document Project 1
High Level Design 
I decided to modify the code for Lab 5 to tailor the needs of Project 1 simply because Lab 5 was doing the exact opposite of this project (i.e. taking a MIPS instruction and converting it to a 32 bit binary string instruction). So, using this idea of reversing the whole process, I looked at ASMParser.cpp which was essentially parsing the MIPS instruction to encode it into a 32 bit instruction, and modified it to MachineParser.cpp which parsed 32 bit instruction to a MIPS word format instruction. At a high level of implementation, the driver class, ASM.cpp (which i slightly modified from the original, as will be explained later) takes as a command line argument the name of the file containing lines of 32 bit MIPS instructions. This file is then passed to the MachineParser class which does the work of parsing each line which represents a MIPS instruction (i.e. breaking the string down into specific sections such as the opcode, operands etc) and then converting those binary representations to actual words, integers and addresses. Certain checks have been placed to ensure that if the instruction is greater than 32 bits, the whole process of parsing the instruction file should stop, and that if the instruction is exactly 32 bits but does not represent any instruction (i.e. has an invalid opcode), then it should be ignored and the next valid instruction should be parsed instead. The opcode field is the first 6 bits of every MIPS instruction, so this opcode was used to separate the instructions into ITYPE, JTYPE and RTYPE. Once the types were known, further parsing was done to find the operands for each instruction type. Once we knew the string operands (meaning the binary strings for each operand) we then moved on to convert the binary values to their decimal representatives for the operands. The register names were simply obtained by tallying the binary value of the operand with the register table which would simply tell us which register represents for example an operand register of decimal value 7.  After going through this routine, we now have all the values for the opcodes, operands, immediates as well as the function fields in the form that we need to create an instruction. Thus our next step was to set the values of an instruction using these specific parameters. Every instruction was then pushed onto a vector so by the end of this parsing routine, we would have a vector containing all the parsed instructions from the input file. Once we had the instruction at hand, all we needed to do was start work on the string output that we would print out to the console for the instruction. The encode method, return type string, returns the string literal that corresponds to the 32 bit MIPS instruction that we parsed and encoded. The categorizatino of the MIPS instructions was once again done primarily using the opcode, since that specifies which operands will be used.
To add more MIPS instructions, the opcode table has to be modified so that MachineParser can access details such as the name of the instsruction and the positions of the operands, the binary literal of the opcode etc. There also might be a need to make minor changes to the MachineParser class which would basically include adding an addition IF statement for some specific instruction. 

Class Design 
ASM.cpp: This is the driver class of the project and takes as a command line argument, the file that contains 32 bit string literals that we have to convert to MIPS instructions. It calls the constructor of MachineParser to create a vector which stores all the instruction objects into the vector. Then it prints out the contents of the vector but before doing so, it checks whether each input line from the file was 32 bits or not. If its anything less than 32 bits, the program quits. A further check is done to ensure that even if the instruction is 32 bits, if it has an undefined opcode meaning it is not a proper instruction, it should not be decoded, and instead the next instruction should be decoded. 
MachineParser.cpp: This class parses and encodes each line of the input file to convert it from a 32 bit string literal to a worded MIPS instsruction. This is done by first breaking the string literal down into operands based off the opcode. Then the operands, the opcode and the functions are convert from their string binary form to decimal form. This is also done using the opcode, as that gives us the type of the instruction. it uses this information to build the instruction which is then pushed onto the vector. then using the RegisterTable class to get the proper register based on the register value and setting the immediate fields by converting them to either a hexadecimal if they are an address field or just leaving them as a decimal if they are not. Once the instruction objects data fields are set that instruction is pushed_back to the vector of instructions stored in ASM.cpp.

Instruction.cpp: This class represents each correct MIPS instruction. The instruction objects have their data fields set in MachineParser and then the encode method takes the instruction and prints out the actual MIPS instruction that the 32 bit string literal represents. 
Opcode.cpp: This class contains all the MIPS instructions that my implementation has access to. It contains accessors so we can get the information about the specific instruction, i.e. the positions of the operands from the opcode table. MachineParser class therefore uses the opcode class to determine the type and other details of each 32 bit binary literal. 

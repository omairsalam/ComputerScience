<!DOCTYPE html>
<html>
  <head>
    <title> Game of Life Documentation</title>
    <meta charset = "UFT-8">
  </head>
  <body>
    <h1> Game of Life Documentation</h1>
    <h2>Approach to the problem </h2>
    <p> I solved this program in three stages. </p>
    <p> The first stage of solving the program was trying to make a algorithm that could look at a two dimensional array counting from the top left corner row column wise. It obviously helped that the game was going to look at the cells in the same order that an array looks at its cells. This code was pretty easy, I used if statements to check the 8 boxes around each cell to see whether they were alive or not. I used a integer variable called liveNeighbours to count the number of liveNeighbours for each cell, and then based on this number and the state of the current cell I was looking at ( meaning whether it was alive or dead originally) i decided whether this cell would be alive or dead in the next generation. I knew that we had to use two arrays, one for the cuurrent generation(firstGen) and one for the next generation(nextGen). After each generation was calculated, the arrays would completely swap all their content, meaning after calculating the next generation based on the specific calculations mentioned later, the array containing the new data (nextGen) would place all its content in the firstGen, which would then become the starting point for the nextGeneration calculation. </p>





    
      <p> The second stage of solving the problem was going to be creating a grid on the screeen, 100 by 100 in dimensions and having 5 pixel for each cell. I used a for loop to create this grid on the screen, slightly modifying the starting coordinates to <pre> (50 + 5j, 50 + 5i, 5,5) </pre> so that for each cell, the dimensions would be the same but the starting cordinates would vary. Notice that the j and i were swapped because when we look at the array, myarraya[i][j], i represents the rows, meaning y axis while j represents the columns meaning x axis, while in the coordinate system, <pre> 50 + 5j</pre> is the x coordinate while <pre> 50+5i </pre>is the y coordinate. Effectively this meant that the forloop would create 10,000 cells, one by one, row by row till all 10,000 cells were created. After creating the grid, the problem of populating the grid rose. I wanted my current generation (firstGen) to be displayed on the grid, and since both the firstGen and the grid itself were two dimensional, this did not pose to be very hard. So the link between the firstGen and the grid was one to one, meaning for every cell in the firstGen, for example firstGen[i][j] there would be a cell on the grid at the coordinates <pre>(50+5j, 50+5i, 5,5) </pre>. I therefore used this link between the two to populate the grid as to the condition of firstGen. I called the repaint() every time a new generation was made so that a new cell using the code fillRect would be created at the specific coordinates of <pre>(50+5j, 50+5i, 5,5) </pre>. I also needed a code for what would happen when a new generation would be made, which would have one particular firstGen[i][j] as 0 which was previously 1. For this I simply put an if statement in the paint method that if the firstGen[i][j]==0  then empty the rectangle at coordinates <pre>(50+5j, 50+5j, 5,5) </pre>. The problem that this created was that by clearing the whole rectangle, it also removed the borders. I had two options to deal with this, the first was that I would remove, 4,4 instead of 5,5 to leave the 1 pixel border. But I decided to go the other way which was creating an empty rectangle at the same cordinates after clearing the rectangle at those cordinates. All of this was more tedious than difficult and I was able to do it through if loops.</p>
      <p> The third stage of solving the problem itself had two sub-stages. The first was using the mouse to click on specific cells to populate them, instead of populating them in the main method. The second was using an action button to start the same instead of automatically starting it when the game was run. For the first problem, the olympic rings lab proved really helpful as I looked at that and reminded myself of how to click on a specific ring that makes a specific box appear which is colored a certain way. This was identical to that. So what I did was, I used the x and the y coordinates of the point where I clicked, put certain restrictions to ensure that only if the click was within the grid, it converts the x and the y coordinates to the indices of i and j, by using the conversion formula <pre>i = (50-Y/5) and j = (50-X/5). </pre>Then I said that if the click would be in that particular cell, make it alive by setting its value to 1 and then call repaint() so it shows up on the grid on the screen. </p>New tools applied </h2>
                                                                                                  <p> We used actionListener and action button for the first time and started the program by clicking on this button, as opposed to the program starting automatically every time it was run. We also used threads for the first time and the sleep thread proved to be very useful as it gave us a chance to not only make certain changes to our input data, but to also see the output data slowly to see whether the result was what we wanted it to be.  </p> 

                                                                                                              <h2> How your algorithm works </h2>
                                                                                                              <p> First we created two two-dimensional arrays: firstGen and nextGen. We also declared a variable called liveNeighbors which will count the number of liveneighbors of a certain coordinate. We decided that the live cells would be represented by 1 or greater than 1,  and the dead cells will be represented by 0(false). We then created a segment of code where we travel through the array and count the live neighbors of each and every index within the array. We created numerous if statements to achieve this. We had to create different segments of codes for the left side of the grid, the right side, top side, the bottom side, coordinates not on borders, left top corner, right top corner, left bottom corner and right bottom corner  Then depending upon the number of live neighbours of each cell, we updated the status of each cell in the nextGen, copied the content of the nextGen into the firstGen, called repaint(), which displayed colored cells based upon which cells with indexes were more than one (alive) or 0 (dead) .</p>

                                                                                                              <p> The program does not crash and neither goes into an infinite loop for actionListener as we dont use action listener directly to call the infinite compilation of next generation, instead, it triggers the variable clicks, that controls whether the next Generation is created and displayed, one by one, untill clicked becomes false. Therefore it never creates a problem of the software getting stuck. </p> 
                                                                                                              <h2> Extra Credit </h2>
                                                                                                              <p> We tried to get both extra credit points. For the first extra credit point, we just used a lot of if statements for specific conditions such as for the leftmost column, in which we would also consider some cells on the rightmost column, the rightmost column for which we would also consider some cells in the leftmost column, the top side, the bottom side, the 4 corners, and finally any other point that did not fall into this specific category, meaning was within the bordering cells of the grid.</p>


                                                                                                                 <p>Second extra credit mark, we just decided to increment the value inside each array[i][j] by 1 every time it was true for the next generation. This effectively meant that the number that was contained in the array at a particular index of [i][j] was not only determining whether the cell was alive or dead ( by being either 0 or greater or equal to 1 ) but also determined the age of the cell if it was alive, as this was the number inside the array at that index position. </p> 
                                                                                                                 <h2> How to launch Program </h2>
                                                                                                                 <p> Open the java file, click on boxes in the grid to make them colored. Click on play/pause button to start the game. KEY NOTE: When the jave file opens, the grid will be displayed, but will disappear when the button appear. The grid is still there and becomes visible when you click inside it ( that is to make the grid visible, click inside the empty area where the grid was before) I have used a click/unclick feature, so if the box you clicked is not the one you wanted to be alive, just click on it again to make it dead. Hope this helps! </p> 
                                                                                                               </body>
                                                                                                                                </html>
